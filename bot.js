const botHelpCommand = "!hawx";
const botAboutCommand = "!hawxbot";
const lineBreak = "\n\uFEFF";

const helpers = require('./modules/helpers.js');
const messages = require('./modules/messages.js');
const gowApi = require('./modules/gowApi.js');
const discord = require('discord.js');
const bot = new discord.Client();

// Define global variables
var botName;

// Define Bot Behaviours
bot.on('ready', () => {

    botName = bot.user.username;

    bot.user.setStatus('online');
    bot.user.setActivity(botHelpCommand, { type: 'LISTENING' });

    console.log(`${botName} is online`);
});

bot.on('message', async message => {

    var discordUser = message.author.username;

    // Don't reply to messages generated by any bot
    if (message.author.bot) return;
    
    // Don't reply to messages generated by this bot
    if (discordUser === botName) return;

    // Parse the message
    let parsedMessage = await helpers.ParseMessage(message);

    // Define the reply
    var data = null;
    var replies = Array();
    var reactions = null;
    var replyToPerson = true;

    switch (parsedMessage.Command) {
        case botAboutCommand:
            if(message.channel != null) message.channel.startTyping();

            replies.push(await messages.AboutThisBot());
            break;

        case botHelpCommand:
            if(message.channel != null) message.channel.startTyping();

            staticCommands = await messages.ListBotCommands(botAboutCommand);
            dynamicCommands = await gowApi.AboutHawxCommands();

            replies.push(staticCommands.replace("[HawxCommands]", dynamicCommands));

            break;

        case '!patchnotes':

            // Disabled
            return;

            if(message.channel != null) message.channel.startTyping();

            data = await gowApi.GetLatestPatchNote();
            if(data == null) {
                replies.push(messages.BotError());
                break;
            }

            replies = replies.concat(data.messages);
            replyToPerson = false;
            break;

        case '!patchnotesmajor':

            // Disabled
            return;

            if(message.channel != null) message.channel.startTyping();

            data = await gowApi.GetLatestMajorPatchNote();
            if(data == null) {
                replies.push(messages.BotError());
                break;
            }

            replies = replies.concat(data.messages);
            replyToPerson = false;
            break;
        
        default:
            
            hawxCommands = await gowApi.ListHawxCommands();
            for(var i=0; i < hawxCommands.commands.length; i++){
                let hawxCommand = hawxCommands.commands[i];

                // Try to match a command
                if(hawxCommand.command == parsedMessage.Command){
                    if(message.channel != null) message.channel.startTyping();

                    // Check for help argument
                    if(parsedMessage.Arguments.length > 0 && parsedMessage.Arguments[0].toLowerCase() =="help") {
                        replies.push(hawxCommand.help);                     
                    } else {
                        // If no arguments are specified then just show the latest data
                        if(parsedMessage.Arguments.length == 0) parsedMessage.Arguments = Array("latest");
                        let hawxApiUrl = hawxCommand.links.href + "/" + parsedMessage.Arguments.join("/");
                        const maxItemCount = 3;

                        let data = await gowApi.GetHawxCommandItems(hawxApiUrl, maxItemCount);
                        
                        // Check whether or not a message was returned
                        if(data.messages.length < 1){
                            var notFoundResponse = hawxCommand.help;
                            notFoundResponse.content = 
                                "Sorry, we can't find anything that matches your query. " +
                                `Here's some help on how to use the **${parsedMessage.Command}** command.${lineBreak}`
                            console.log(notFoundResponse);
                            replies.push(notFoundResponse); 
                        } else {
                            replies = replies.concat(data.messages);
                        }

                        replyToPerson = false;
                    }
                }
            }
            break;
    }

    await messages.SendReplies(discord, bot, message, replies, reactions, replyToPerson);
});

// Login to Discord as the Bot
bot.login(process.env.BOT_TOKEN); 